#!/bin/bash
# Prints dimensions of a matrix, transposes a matrix, calculates
# the mean vector of a matrix, adds two matrices, and multiplies two matrices.

# Declare variables
# catch
#trap "rm -f $temp*"
afile="$afile"
matCommand="$1"
inputFile1="$2"
inputFile2="$3"
stdTemp="stdTemp"
# temp variables
columnCount=0
rowCount=0
temp1="temp1"
temp2="temp2"
tempeee="tempeee"
tempeee2="tempeee2"
# If first argument is dims and 2nd argument file name exists and 
# there are 2 or fewer arguments, print dimensions of matrix
function perror()
{
	echo -en "\e[31mERROR\e[0m: " >&2
	[ $# -gt 0 ] && echo "$*" >&2
	exit 1
}
function dims()
{
	echo "$3 $2"
	rm -f temp*
	exit 0
}


function transpose()
{
	i=1
	if [[ ! -e $1 ]]
	then
		perror "File does not exist"
	elif [[ ! -r $1 ]]
	then
		perror "File is unreadable"
	fi
	
		k=0 
		while [[ $i -le $2 ]]
		do
			cut -f $i $1 > tempCC
			(( i++ ))
			cat tempCC | tr '\n' '\t' >> tempRC
			echo "" >> tempRC
		done
		sed 's/[[:blank:]]*$//' tempRC > tempeee2
		cat tempeee2 > heavy
	if [ "$4" == "45" ]
	then
		cat tempeee2 > empeee2
		rm -f temp*
		return 0
	
	else
		cat tempeee2
		rm -f temp*
		exit 0
	fi
}


# Calculates means of matrix columns
function mean()
{
	i=1
	j=0
	total=0
	divby=0

	while [[ $i -le $2 ]]
	do
		cut -f $i $1 > tempCC
		(( i++ ))
		cat tempCC | tr '\n' '\t' >> tempRC
		echo "" >> tempRC
	done
	sed 's/[[:blank:]]*$//' tempRC > tempeee
	
	while read meannum
	do
		for val in $meannum
		do
			total=$(( $total + $val ))		
			(( j++ ))
		done
		total=$(( ($total + ($j/2)*( ($total>0)*2-1 )) / $j ))
		echo $total >> tempMean
		total=0
		j=0
	done < tempeee
	cat tempMean | tr '\n' '\t' >> tempPrint
	sed 's/[[:blank:]]*$//' tempPrint > tempFinal
	echo "" >> tempFinal
	cat tempFinal
	rm -f temp*
	exit 0

}


function add()
{
	file=3
	while read myLine
	do
		echo $myLine >> temp1
		rowCount1=$(( $rowCount1 + 1 ))
		if [[ $rowCount1 == 1 ]]
		then
			for val in $myLine
			do
				colCount1=$(( $colCount1 + 1 ))
			done
		fi
	done < $1


	while read myLine
	do
		echo $myLine >> temp2
		rowCount2=`expr $rowCount2 + 1`
		if [[ $rowCount2 == 1 ]]
		then
			for val in $myLine
			do
				colCount2=$(( $colCount2 + 1 ))
			done
		fi
	done < $2

	if [ $rowCount1 -eq $rowCount2 ] && [ $colCount1 -eq $colCount2 ]
	then
	
	i=1
	while IFS= read -r aline && IFS= read -r bline <&3
	do
		FILE=4
		echo $aline > tempavalues
		echo $bline > tempbvalues
		cat tempavalues | tr ' ' '\t' > tempa2values
		cat tempbvalues | tr ' ' '\t' > tempb2values
		while [ $i -le $colCount1 ]
		do
			onea=$(cut -f $i tempa2values)
			oneb=$(cut -f $i tempb2values)
			valueadd=`expr $onea + $oneb`
			echo $valueadd >> tempvalues
			(( i++ ))
		done
		cat tempvalues | tr '\n' '\t' >> tempfinalM
		i=1
		sed 's/[[:blank:]]*$//' tempfinalM >> temprealfinalM
		echo "" >> temprealfinalM
		rm -f tempfinalM tempvalues
	done <$1 3<$2
	cat temprealfinalM
	rm -f temp*
		exit 0
	
	else
		rm -f temp*
		perror "Matrice suc"
	fi	

}

function multiply()
{
	file=3
	while read myLine
	do
		echo $myLine >> temp1
		rowCount1=$(( $rowCount1 + 1 ))
		if [[ $rowCount1 == 1 ]]
		then
			for val in $myLine
			do
				colCount1=$(( $colCount1 + 1 ))
			done
		fi
	done < $1


	while read myLine
	do
		#echo $myLine >> temp2
		rowCount2=`expr $rowCount2 + 1`
		if [[ $rowCount2 == 1 ]]
		then
			for val in $myLine
			do
				colCount2=$(( $colCount2 + 1 ))
			done
		fi
	done < $2
	if [ $colCount1 -ne $rowCount2 ]
	then
		rm -f temp*
		perror "hells na"
	else	

	transpose $2 $colCount2 $rowCount2 45	
	i=1
	j=1
	k=1
	aXb=0
	
#arg to is now tempeee2
#starting major changes here
	#outer loop for 1st matrix
	####while [ $i -le $rowCount1 ]
	###do
		#inner loop for each item in matrix1
	while read aline     #IFS= read aline && IFS= read bline <&3
	do
		
		echo $aline > linea
		cat linea | tr ' ' '\t' > linea2
		sed 's/[[:blank:]]*$//' linea2 > linea3
		while read bline
		do
			echo $bline > lineb
			cat lineb | tr ' ' '\t' > lineb2
			sed 's/[[:blank:]]*$//' lineb2 > lineb3
		

			while [ $j -le $colCount1 ]
			do
				onea=$(cut -f $j linea3)
				oneb=$(cut -f $j lineb3)
				valMult=`expr $onea \* $oneb`
				aXb=`expr $aXb + $valMult`
				(( j++ ))
			done			
			j=1	
			echo $aXb >> MultF
			aXb=0
		done < empeee2
	cat MultF | tr '\n' '\t' > MultF2
	sed 's/[[:blank:]]*$//' MultF2 >> MultF3
	echo "" >> MultF3
		
		rm -f MultF2 MultF
		done <$1 #3<empeee2
		cat MultF3	
		rm -f temp* lin* emp* Mult* heavy
		exit 0
	
	fi	

}








#stdin capture method
datafilepath="$datafilepath"
temp1="$temp1"
temp2="$temp2"
# If the command is bad (i.e. not one of our operations)
if [ "$1" != "add" ] && [ "$1" != "transpose" ] && [ "$1" != "multiply" ] && [ "$1" != "mean" ] && [ "$1" != "dims" ]
then
	perror "Bad command"
# If there are too many arguments for dims, error
elif [ "$#" == "3" ] && [ $1 == "dims" ]
then
	perror "too many arguments for this operation"
# If there are too many arguments for transpose, error
elif [ "$#" == "3" ] && [ $1 == "transpose" ]
then
	perror "too many arguments for this operation"
# If there are too many arguments for mean, error
elif [ "$#" == "3" ] && [ $1 == "mean" ]
then
	perror "too many arguments for this operation"
# If there is not a 3rd argument for add, error 
elif [ ! "$3" ] && [ "$1" == "add" ]
then
	perror "too few arguments for this operation"
# If there is not a 3rd arugument for multiply, error
elif [ ! $3 ] && [ $1 == "multiply" ]
then
	perror "too few arguments for this operation"
# If there is only argument, read from stdin
elif [[ "$#" == "1" ]]  
then
	puppies=192
	afile="/dev/stdin"
	while read anum
	do
		mystring=$anum
		for num in $mystring
		do
			echo $num >> tempy
		done
		cat tempy | tr '\n' '\t' >> tempy2
		rm -f tempy	
		echo "" >> tempy2
	
	done < $afile	
	if [ ! -e tempy2 ]
	then
		$1 0 0
	else
		sed 's/[[:blank:]]*$//' tempy2 > tempy66
		while read myLine
		do
			rowCount=`expr $rowCount + 1`
			if [[ $rowCount == 1 ]]
			then
				for val in $myLine
				do
					columnCount=$(( $columnCount + 1 ))
				done
			fi
		done < tempy2
		$1 tempy66 "$columnCount" "$rowCount"
	fi
# If there are only 2 arguments, read from file
else
	# If the file does not exist, error
	if [[ ! -e $2 ]]
	then
		perror "File $2 does not exist"
	fi
	if [ $3 ] && [ ! -e $3 ]
	then
		perror "File $3 does not exist"	
	fi
	# If there is only one file to process	
	if [ "$#" == "2" ]
	then 
		while read myLine
		do
			rowCount=`expr $rowCount + 1`
			if [[ $rowCount == 1 ]]
			then
				for val in $myLine
				do
					columnCount=$(( $columnCount + 1 ))
				done
			fi
		done < $2
		datafilepath=$2
		$1 $datafilepath "$columnCount" "$rowCount"
	# Else we have two files to process
	else

		$1 $2 $3 
		


	fi	

fi

